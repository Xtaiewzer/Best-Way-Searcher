from collections import deque


# Функция поиска кратчайшего пути
# Сокращение от Shortest Way Meter - Измеритель Кратчайшего Пути
def SWM(field, s, t):
    # field - массив строк, представляющий собой крату
    # s - координаты точки старта
    # t - координаты конечной точки
    w = len(field)  # Длинна поля в ширину
    h = len(field[0])  # Длинна поля в высоту
    INF = 10 ** 4  # Невозможно большая длинна пути по умолчанию
    delta = ((0, -1), (0, 1), (1, 0), (-1, 0))  # Координаты клеток-соседей
    d = [[INF] * h for _ in range(w)]  # Список длин известных нам путей
    p = [[None] * h for _ in range(w)]  # Список с координатами кратчайшего пути
    used = [[False] * h for _ in range(w)]  # Список уже проверенных клеток
    queue = deque()  # Очередь из клеток с кратчайшим путём
    # В двумерном массиве d хранятся длинны из этой точки в точку старта
    d[s[0]][s[1]] = 0  # Длинна из точки старта в саму себя равна нулю
    used[s[0]][s[1]] = True  # Известная нам точка старта уже была проверенна
    queue.append(s)  # Добавляем точку старта в очередь
    while len(queue) != 0:
        x, y = queue.popleft()  # Достаем координаты крайнего элемента из очереди
        for dx, dy in delta:  # Рассматриваем его соседей:
            nx, ny = x + dx, y + dy  # Узнаем координаты соседних клеток
            if 0 < nx < w and 0 < ny < h \
                    and not used[nx][ny] and field[nx][ny] != '#':  # Проверяется тип клетки:
                # Мы не рассматриваем препятствия и не выходим за границы поля
                d[nx][ny] = d[x][y] + 1  # Узнаем расстояние из клетки до её соседа
                p[nx][ny] = (x, y)  # Отмечаем путь в соответствующем двумерном массиве
                used[nx][ny] = True  # Отмечаем клетку как проверенную
                queue.append((nx, ny))  # Добавляем её соседей в соответствующий массив
    # Расстояние из клетки в соседнюю клетку всегда равно единице.
    # То есть, из клетки-соседа нужно пройти путь, больший на 1, чем путь
    # Из исходной клетки, только если это не предыдущая клетка
    # Путь из предыдущей клетки всегда на 1 меньше, чем из исходной

    # Теперь с помощью полученной информации мы получаем список ходов,
    # Которые нужно сделать, чтобы попасть из точки старта в конечную точку
    # По самому короткому пути из всех возможных
    cur = t  # Координаты текущей клетки равны координатам конечной точки
    way = []  # Массив ходов, которые максимально быстро приведут нас в конечную точку
    while 1:  # С помощью двумерного массива p восстанавливаем путь из
        # Конечной точки t в начальную точку s
        next = p[cur[0]][cur[1]]  # Узнаем следующую клетку
        if next == None:  # Если следующей клетки не существует, то мы пришли
            break  # В начальную точку s
        way.append((cur[0] - next[0], cur[1] - next[1]))  # Узнаем сторону, в которую
        # Нужно сделать шаг для того, чтобы добраться в начальную точку s
        cur = next  # Текущая точка теперь равна следующей точке
    way.reverse()  # Разворачиваем список ходов из конечной точки t в начальную точку s
    # По максимально короткому пути для того, чтобы получить список ходов
    # Из начальной точки s в конечную точку t по максимально короткому пути
    return (way, d[t[0]][t[1]])  # Возвращаем кортеж из списка ходов, которые необходимо
    # Совершить для того, чтобы из начальной точки s, чтобы попасть в конечную точку t
    # По максимально короткому пути и длину этого самого пути


def test():
    file = open("path.txt")
    field = file.readlines()
    n = len(field)
    # m = len(field[0]) - 1
    s = None
    t = None

    for i in range(n):
        line = field[i]
        sf = line.find('S')
        if sf != -1:
            s = (i, sf)
        tf = line.find('T')
        if tf != -1:
            t = (i, tf)

    st = ''
    for i in field:
        st += i
    print(st)
    print(s, t)
    way = SWM(field, s, t)
    print(way[0])
    print(way[1])


test()
